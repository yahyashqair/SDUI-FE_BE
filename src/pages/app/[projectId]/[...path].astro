---
import Layout from "../../../layouts/Layout.astro";
import { getAppBlueprint, parseUISchema } from "../../../platform/renderer";
import { executeFunction } from "../../../platform/executor";
import { SDUIRenderer } from "../../../sdui/renderer";
import { PlatformDB } from "../../../db/platform";

const { projectId, path } = Astro.params;

if (!projectId) return Astro.redirect("/404");

const project = PlatformDB.getProject(projectId);
if (!project) return Astro.redirect("/404");

// API Handling
if (Astro.request.method === "POST") {
    const url = new URL(Astro.request.url);
    // Check if it's an action call
    // SDUI usually sends actions via a specific endpoint or we can handle it here if it's a form submission

    // For this demo, we assume the client-side SDUI renderer sends JSON POSTs to this URL
    // with an "action" field or similar, OR we follow a convention like `?_action=functionName`

    // Let's assume the body contains { functionName, params }
    try {
        const body = await Astro.request.json();
        if (body.functionName) {
            const result = await executeFunction(
                projectId,
                PlatformDB.getFunctions(projectId).find(
                    (f) => f.name === body.functionName,
                )?.code || "",
                body.params || {},
            );
            return new Response(JSON.stringify(result), {
                headers: { "Content-Type": "application/json" },
            });
        }
    } catch (e) {
        // Not a JSON request or failed
    }
}

// Check for _serverless path manually if needed, but the dynamic route catches everything.
// If the path ends in something specific we could route differently.

const blueprint = getAppBlueprint(projectId);
if (!blueprint) {
    return new Response("App not published or empty", { status: 404 });
}

const uiSchema = parseUISchema(blueprint);

// We need to inject the projectId into the renderer context so it knows where to send API requests
// The SDUIRenderer in this codebase might need a slight tweak to support a base URL for actions,
// or we can handle it by ensuring actions in the schema use a relative URL that this page handles.
// The `agent.ts` generates actions with `type: 'server'` and `functionName`.
// The client-side renderer needs to know how to handle `type: 'server'`.
---

<Layout title={project.name}>
    <script define:vars={{ projectId }}>
        // Global handler for server actions
        window.SERVER_ACTION_HANDLER = async (functionName, params) => {
            const response = await fetch(window.location.href, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ functionName, params }),
            });
            return await response.json();
        };
    </script>

    <!-- We need to modify SDUIRenderer or provide a context provider to handle the actions -->
    <!-- For now, we assume SDUIRenderer can render the JSON.
         We might need to map the "server" action type to a client-side handler. -->

    <div class="min-h-screen bg-gray-50">
        <SDUIRenderer client:load component={uiSchema} />
    </div>
</Layout>
